<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ThreeJSEvolution - ç‰©ç†å¼•æ“æ¼”ç¤º</title>
    <style>
        * { 
            margin: 0; 
            padding: 0; 
            box-sizing: border-box;
        }
        body { 
            overflow: hidden; 
            background: #0a0a1a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        canvas { 
            display: block; 
        }
        
        /* çŠ¶æ€é¢æ¿ */
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #info div {
            margin: 5px 0;
        }
        #info span {
            color: #00ff88;
            font-weight: bold;
        }
        
        /* æ§åˆ¶é¢æ¿ */
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 12px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .btn {
            padding: 12px 24px;
            background: linear-gradient(135deg, #00c8ff, #0080ff);
            border: none;
            border-radius: 10px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 200, 255, 0.3);
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 200, 255, 0.5);
        }
        .btn:active {
            transform: translateY(0);
        }
        .btn-blue {
            background: linear-gradient(135deg, #6495ed, #4169e1);
            box-shadow: 0 4px 15px rgba(100, 149, 237, 0.3);
        }
        .btn-blue:hover {
            box-shadow: 0 6px 20px rgba(100, 149, 237, 0.5);
        }
        .btn-red {
            background: linear-gradient(135deg, #ff6b6b, #ee5a5a);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }
        .btn-red:hover {
            box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
        }
        .btn-green {
            background: linear-gradient(135deg, #00ff88, #00cc6a);
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
        }
        .btn-green:hover {
            box-shadow: 0 6px 20px rgba(0, 255, 136, 0.5);
        }
        
        /* æç¤ºä¿¡æ¯ */
        #hint {
            position: absolute;
            top: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.6);
            padding: 12px 18px;
            border-radius: 10px;
            font-size: 13px;
        }
    </style>
</head>
<body>
    <!-- çŠ¶æ€æ˜¾ç¤º -->
    <div id="info">
        <div>ğŸ® ThreeJSEvolution <span id="version">v1.0</span></div>
        <div>ğŸ“¦ å¯¹è±¡æ•°é‡: <span id="objCount">0</span></div>
        <div>âš¡ FPS: <span id="fps">60</span></div>
    </div>
    
    <!-- æç¤º -->
    <div id="hint">
        ğŸ–±ï¸ ç‚¹å‡»ç‰©ä½“æ–½åŠ åŠ› | æŒ‰ç©ºæ ¼é”®è·³è·ƒ
    </div>
    
    <!-- æ§åˆ¶æŒ‰é’® -->
    <div id="controls">
        <button class="btn" onclick="spawnRandomBox()">ğŸ“¦ ç”Ÿæˆæ–¹å—</button>
        <button class="btn" onclick="spawnRandomSphere()">âš½ ç”Ÿæˆçƒä½“</button>
        <button class="btn btn-blue" onclick="spawnMany()">ğŸ’¥ æ‰¹é‡ç”Ÿæˆ</button>
        <button class="btn btn-green" onclick="explodeAll()">ğŸ”¥ çˆ†ç‚¸æ•ˆæœ</button>
        <button class="btn btn-red" onclick="resetScene()">ğŸ”„ é‡ç½®åœºæ™¯</button>
    </div>

    <!-- å¼•å…¥åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/cannon@0.6.2/build/cannon.min.js"></script>
    
    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            gravity: -20,
            physicsStep: 1/60,
            colors: [0x00ff88, 0xff6b6b, 0x4ecdc4, 0xffaa00, 0x9b59b6, 0x00ccff, 0xff69b4, 0x32cd32],
            groundSize: 50
        };

        // ==================== å…¨å±€å˜é‡ ====================
        let scene, camera, renderer, world, clock;
        let objects = [];
        let lastTime = 0;
        let frameCount = 0;
        let lastFpsTime = 0;

        // ==================== åˆå§‹åŒ– ====================
        function init() {
            console.log('ğŸš€ åˆå§‹åŒ– ThreeJSEvolution ç‰©ç†å¼•æ“...');
            
            // 1. åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a1a);
            scene.fog = new THREE.Fog(0x0a0a1a, 20, 80);

            // 2. åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(
                60, window.innerWidth / window.innerHeight, 0.1, 1000
            );
            camera.position.set(12, 10, 12);
            camera.lookAt(0, 0, 0);

            // 3. åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ 
                antialias: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // 4. åˆ›å»ºç‰©ç†ä¸–ç•Œ
            world = new CANNON.World();
            world.gravity.set(0, CONFIG.gravity, 0);
            world.broadphase = new CANNON.NaiveBroadphase();
            world.solver.iterations = 10;
            world.defaultContactMaterial.friction = 0.5;
            world.defaultContactMaterial.restitution = 0.3;

            // 5. æ·»åŠ å…‰ç…§
            setupLights();

            // 6. åˆ›å»ºåœ°é¢
            createGround();

            // 7. åˆ›å»ºæ¼”ç¤ºç‰©ä½“
            createDemoObjects();

            // 8. è®¾ç½®äº‹ä»¶ç›‘å¬
            setupEventListeners();

            // 9. å¯åŠ¨åŠ¨ç”»å¾ªç¯
            clock = new THREE.Clock();
            animate();

            console.log('âœ… ThreeJSEvolution åˆå§‹åŒ–å®Œæˆï¼');
            console.log('ğŸ“¦ å½“å‰ç‰©ä½“æ•°é‡:', objects.length);
        }

        // ==================== å…‰ç…§è®¾ç½® ====================
        function setupLights() {
            // ç¯å¢ƒå…‰
            const ambient = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambient);

            // ä¸»æ–¹å‘å…‰
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(10, 20, 10);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.near = 0.5;
            dirLight.shadow.camera.far = 50;
            dirLight.shadow.camera.left = -20;
            dirLight.shadow.camera.right = 20;
            dirLight.shadow.camera.top = 20;
            dirLight.shadow.camera.bottom = -20;
            scene.add(dirLight);

            // è¡¥å…‰
            const fillLight = new THREE.DirectionalLight(0x88ccff, 0.3);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);
        }

        // ==================== åˆ›å»ºåœ°é¢ ====================
        function createGround() {
            // Three.js åœ°é¢
            const groundGeo = new THREE.PlaneGeometry(CONFIG.groundSize, CONFIG.groundSize);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x1a1a2e,
                roughness: 0.8,
                metalness: 0.2
            });
            const groundMesh = new THREE.Mesh(groundGeo, groundMat);
            groundMesh.rotation.x = -Math.PI / 2;
            groundMesh.receiveShadow = true;
            groundMesh.name = 'ground';
            scene.add(groundMesh);

            // ç½‘æ ¼è¾…åŠ©çº¿
            const grid = new THREE.GridHelper(CONFIG.groundSize, 50, 0x333355, 0x222244);
            grid.position.y = 0.01;
            scene.add(grid);

            // Cannon.js åœ°é¢
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({ 
                mass: 0,
                material: new CANNON.Material('ground')
            });
            groundBody.addShape(groundShape);
            groundBody.quaternion.setFromAxisAngle(
                new CANNON.Vec3(1, 0, 0), -Math.PI / 2
            );
            world.addBody(groundBody);
        }

        // ==================== åˆ›å»ºæ–¹å— ====================
        function createBox(x, y, z, width, height, depth, mass = 1, color = null) {
            // éšæœºé¢œè‰²æˆ–æŒ‡å®šé¢œè‰²
            const meshColor = color || CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            
            // Three.js ç½‘æ ¼
            const geometry = new THREE.BoxGeometry(width, height, depth);
            const material = new THREE.MeshStandardMaterial({
                color: meshColor,
                roughness: 0.4,
                metalness: 0.3
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js åˆšä½“
            const shape = new CANNON.Box(new CANNON.Vec3(width/2, height/2, depth/2));
            const body = new CANNON.Body({
                mass: mass,
                material: new CANNON.Material('box')
            });
            body.addShape(shape);
            body.position.set(x, y, z);
            body.linearDamping = 0.1;
            body.angularDamping = 0.1;
            world.addBody(body);

            const obj = { mesh, body, type: 'box' };
            objects.push(obj);
            
            console.log('ğŸ“¦ æ–¹å—åˆ›å»ºæˆåŠŸ:', { x, y, z, width, height, depth });
            return obj;
        }

        // ==================== åˆ›å»ºçƒä½“ ====================
        function createSphere(x, y, z, radius, mass = 1, color = null) {
            // éšæœºé¢œè‰²æˆ–æŒ‡å®šé¢œè‰²
            const meshColor = color || CONFIG.colors[Math.floor(Math.random() * CONFIG.colors.length)];
            
            // Three.js ç½‘æ ¼
            const geometry = new THREE.SphereGeometry(radius, 32, 32);
            const material = new THREE.MeshStandardMaterial({
                color: meshColor,
                roughness: 0.3,
                metalness: 0.4
            });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.set(x, y, z);
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);

            // Cannon.js åˆšä½“
            const shape = new CANNON.Sphere(radius);
            const body = new CANNON.Body({
                mass: mass,
                material: new CANNON.Material('sphere')
            });
            body.addShape(shape);
            body.position.set(x, y, z);
            body.linearDamping = 0.1;
            body.angularDamping = 0.1;
            world.addBody(body);

            const obj = { mesh, body, type: 'sphere' };
            objects.push(obj);
            
            console.log('âš½ çƒä½“åˆ›å»ºæˆåŠŸ:', { x, y, z, radius });
            return obj;
        }

        // ==================== éšæœºç”Ÿæˆæ–¹å— ====================
        function spawnRandomBox() {
            const x = (Math.random() - 0.5) * 8;
            const z = (Math.random() - 0.5) * 8;
            const size = 0.5 + Math.random() * 0.8;
            const y = 5 + Math.random() * 5;
            createBox(x, y, z, size, size, size);
            updateUI();
        }

        // ==================== éšæœºç”Ÿæˆçƒä½“ ====================
        function spawnRandomSphere() {
            const x = (Math.random() - 0.5) * 8;
            const z = (Math.random() - 0.5) * 8;
            const radius = 0.3 + Math.random() * 0.5;
            const y = 5 + Math.random() * 5;
            createSphere(x, y, z, radius);
            updateUI();
        }

        // ==================== æ‰¹é‡ç”Ÿæˆ ====================
        function spawnMany() {
            console.log('ğŸ’¥ å¼€å§‹æ‰¹é‡ç”Ÿæˆ...');
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    const x = (Math.random() - 0.5) * 6;
                    const z = (Math.random() - 0.5) * 6;
                    const size = 0.4 + Math.random() * 0.6;
                    createBox(x, 10 + i * 2, z, size, size, size);
                }, i * 100);
                
                setTimeout(() => {
                    const x = (Math.random() - 0.5) * 6;
                    const z = (Math.random() - 0.5) * 6;
                    const radius = 0.3 + Math.random() * 0.4;
                    createSphere(x, 12 + i * 2, z, radius);
                }, i * 100 + 50);
            }
            
            setTimeout(updateUI, 800);
        }

        // ==================== çˆ†ç‚¸æ•ˆæœ ====================
        function explodeAll() {
            console.log('ğŸ”¥ çˆ†ç‚¸æ•ˆæœï¼');
            objects.forEach(obj => {
                const force = new CANNON.Vec3(
                    (Math.random() - 0.5) * 100,
                    50 + Math.random() * 50,
                    (Math.random() - 0.5) * 100
                );
                obj.body.applyImpulse(force, obj.body.position);
            });
        }

        // ==================== é‡ç½®åœºæ™¯ ====================
        function resetScene() {
            console.log('ğŸ”„ é‡ç½®åœºæ™¯...');
            
            // ç§»é™¤æ‰€æœ‰ç‰©ä½“
            objects.forEach(obj => {
                scene.remove(obj.mesh);
                world.removeBody(obj.body);
            });
            objects = [];
            
            // é‡æ–°åˆ›å»ºæ¼”ç¤ºç‰©ä½“
            createDemoObjects();
            updateUI();
            
            console.log('âœ… åœºæ™¯å·²é‡ç½®');
        }

        // ==================== åˆ›å»ºæ¼”ç¤ºç‰©ä½“ ====================
        function createDemoObjects() {
            // åˆ›å»ºå‡ ä¸ªæ¼”ç¤ºç”¨çš„ç‰©ä½“
            createBox(-2, 2, 0, 1, 1, 1, 1, 0xff6b6b);
            createSphere(2, 2, 0, 0.6, 1, 0x00ff88);
            createBox(0, 4, 0, 0.8, 0.8, 0.8, 1, 0x4ecdc4);
            createSphere(0, 6, 0, 0.5, 1, 0xffaa00);
            
            updateUI();
        }

        // ==================== äº‹ä»¶ç›‘å¬ ====================
        function setupEventListeners() {
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);

            // é”®ç›˜è¾“å…¥
            window.addEventListener('keydown', onKeyDown);

            // é¼ æ ‡ç‚¹å‡»ï¼ˆå°„çº¿æ£€æµ‹ï¼‰
            const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

            window.addEventListener('click', (event) => {
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(scene.children);

                if (intersects.length > 0) {
                    // æ‰¾åˆ°ç‚¹å‡»çš„ç‰©ä½“
                    const hitObj = objects.find(o => o.mesh === intersects[0].object);
                    if (hitObj) {
                        // æ–½åŠ å‘ä¸Šçš„åŠ›
                        const force = new CANNON.Vec3(
                            (Math.random() - 0.5) * 30,
                            40,
                            (Math.random() - 0.5) * 30
                        );
                        hitObj.body.applyImpulse(force, hitObj.body.position);
                        
                        console.log('ğŸ¯ å‡»ä¸­ç‰©ä½“ï¼æ–½åŠ åŠ›:', force);
                    }
                }
            });

            // é¼ æ ‡ç§»åŠ¨ï¼ˆç®€å•è§†è§’æ§åˆ¶ï¼‰
            let isDragging = false;
            let previousMousePosition = { x: 0, y: 0 };

            window.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'BUTTON') return;
                isDragging = true;
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const deltaMove = {
                    x: e.clientX - previousMousePosition.x,
                    y: e.clientY - previousMousePosition.y
                };

                // ç®€å•æ—‹è½¬ç›¸æœº
                const angle = deltaMove.x * 0.01;
                const radius = Math.sqrt(
                    camera.position.x ** 2 + 
                    camera.position.z ** 2
                );
                const currentAngle = Math.atan2(camera.position.x, camera.position.z);
                
                camera.position.x = radius * Math.sin(currentAngle + angle);
                camera.position.z = radius * Math.cos(currentAngle + angle);
                camera.lookAt(0, 0, 0);

                previousMousePosition = { x: e.clientX, y: e.clientY };
            });

            previousMousePosition = { x: 0, y: 0 };
        }

        // ==================== é”®ç›˜äº‹ä»¶ ====================
        function onKeyDown(event) {
            if (event.code === 'Space') {
                event.preventDefault();
                // ç©ºæ ¼é”®ï¼šæ‰€æœ‰ç‰©ä½“è·³è·ƒ
                objects.forEach(obj => {
                    obj.body.velocity.y = 10;
                });
                console.log('â¬†ï¸ æ‰€æœ‰ç‰©ä½“è·³è·ƒï¼');
            }
            
            // Ré”®ï¼šé‡ç½®
            if (event.code === 'KeyR') {
                resetScene();
            }
        }

        // ==================== çª—å£è°ƒæ•´ ====================
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ==================== æ›´æ–°UI ====================
        function updateUI() {
            document.getElementById('objCount').textContent = objects.length;
        }

        // ==================== åŠ¨ç”»å¾ªç¯ ====================
        function animate(time) {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();

            // ç‰©ç†æ›´æ–°
            world.step(CONFIG.physicsStep, delta, 3);

            // åŒæ­¥ Three.js å’Œ Cannon.js
            objects.forEach(obj => {
                obj.mesh.position.copy(obj.body.position);
                obj.mesh.quaternion.copy(obj.body.quaternion);
            });

            // æ¸²æŸ“
            renderer.render(scene, camera);

            // è®¡ç®— FPS
            frameCount++;
            const currentTime = performance.now();
            if (currentTime - lastFpsTime >= 1000) {
                document.getElementById('fps').textContent = frameCount;
                frameCount = 0;
                lastFpsTime = currentTime;
            }
        }

        // ==================== å¯åŠ¨ ====================
        init();
    </script>
</body>
</html>
